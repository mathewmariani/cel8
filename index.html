<!DOCTYPE html>
<html data-bs-theme="dark">

<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>
cel8 User-Manual
</title>

<!-- google fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@500;700;900&display=swap" rel="stylesheet">

<link href="./assets/main.css" rel="stylesheet">

<script>
// https://flatuicolors.com/palette/ca
const palette = ["#ff9ff3", "#feca57", "#ff6b6b", "#48dbfb", "#1dd1a1"];
window.addEventListener("mousedown", (e) => {
  const color = palette.shift();
  document.documentElement.style.setProperty("--highlight-background", color);
  palette.push(color);
});
</script>

</head>
<body class="container" id="top">

<main class="page-content">
<header>
  <h1>cel8 User-Manual</h1>
  <p>
    cel8 v0.0.1<br>
    <a href="https://github.com/mathewmariani/cel8">
      https://github.com/mathewmariani/cel8
    </a><br>
    Author: Mathew Mariani<br>
  </p>
  <p>cel8 is built with:</p>
  <ul>
    <li>Sokol <a href="https://github.com/floooh/sokol">https://github.com/floooh/sokol</a></li>
  </ul>
</header>
<hr>
<details>
  <summary>
    Content: Program Structure | API Reference
  </summary>
  <ul>
    <li>
      <a href="#program-structure">Program Structure</a>
    </li>
    <li>
      <a href="#api-reference">API Reference</a>
      <ul>
        <li>
          <a href="#memory">Memory</a>
        </li>
        <li>
          <a href="#system">System</a>
        </li>
        <li>
          <a href="#graphics">Graphics</a>
        </li>
      </ul>
    </li>
  </ul>
</details>
<hr><h2>Welcome to cel8</h2>
<p>cel8 is a *tiny* framework for creating grid-based games in c99.</p>
<p>The sparse api of cel8 was designed to encourage smaller projects, and to give cel8 a more timely look and feel.</p>



<h2>Memory</h2>
<p>cel8 has &lt;4kb of RAM: see layout below.
This memory can be accessed with the functions <code>c8_peek</code>, <code>c8_poke</code>, <code>c8_memcpy</code>, <code>c8_memset</code>.</p>
<h3>Memory Layout</h3>
<pre><code class="language-c">/*
    0x0000: color mapping
    0x000F: color palette
    0x003F: draw color
    0x0040: random state
    0x0044: unused
    0x0050: font atlas
    0x0450: screen buffer
*/
</code></pre>
<p>The screen buffer is composed of interleved data; the first two bytes of memory represent the color and the glyph, respectively</p>
<h5>u8 c8_peek(const u32 addr, const u32 index)</h5>
<p>Read <code>n</code> bytes from an address in ram. If <code>n</code> is not specified the <code>peek()</code> will return the first byte.</p>
<p>For example, to read the first two bytes of video memory:</p>
<pre><code class="language-c">u8 value = c8_peek(0x0450, 0x00);
</code></pre>
<h5>void c8_poke(const u32 addr, const u32 index, const u8 value)</h5>
<p>Write a single bytes to an address in ram.</p>
<h5>u16 c8_peek2(const u32 addr, const u32 index)</h5>
<h5>void c8_poke2(const u32 addr, const u32 index, const u8 value)</h5>
<h5>u32 c8_peek4(const u32 addr, const u32 index)</h5>
<h5>void c8_poke4(const u32 addr, const u32 index, const u16 value)</h5>
<p>16-bit and 32-bit variations of <code>c8_peek</code> and <code>c8_poke</code> are also offered.</p>
<h5>void c8_memcpy(void *dst, const void *src, size_t len)</h5>
<p>Copies the values of <code>len</code> bytes from the location pointed to by <code>src</code> directly to the memory block pointed to by <code>dst</code>.</p>
<h5>void c8_memset(void *dst, int value, size_t len)</h5>
<p>Sets the first <code>len</code> bytes of the block of memory pointed by <code>dst</code> to the specified <code>value</code>.</p>

<h2>System</h2>
<h5>void c8_stat(u8 n)</h5>
<p>Gets the system information where <code>n</code> can be:</p>
<pre><code class="language-c">/*
    0x0       : version string
    0x1       : frame time
    0x2..0x3  : mouse x, y
    0x4..0x9  : GMT time: year, month, day, hour, minute, second
    0xA..0xF  : Local time: ...
*/
</code></pre>
<h5>void c8_rnd(void)</h5>
<p>Returns a 16-bit pseudo random number.</p>
<p>The random number generator is mapped to adresses <code>0x0040..0x0043</code>. Where the first two bytes represent the seed, and the last two are the high/low values of the ouput.</p>
<p>Calling <code>c8_rnd()</code> will generate a new a random number.</p>
<h5>void c8_time(void)</h5>
<p>Returns the value of a timer, in seconds, with an unspecified starting time.</p>
<p>Multiple calls of <code>c8_time()</code> during the same frame will always return the same result.</p>

<h2>Graphics</h2>
<p>cel8 has a fixed capacity of 128 8x8 pixel glyphs.</p>
<p>All drawing operations in cel8 are subject to the current color. The current color is seperated into background and foreground. These are determined, respectively, by the high and low nibbles of the set color.</p>
<h5>void c8_cls(u8 clr, u8 chr)</h5>
<p>Clears the screen to a specified color and character.</p>
<h5>void c8_color(u8 clr)</h5>
<p>Set the current colour to be used by drawing functions.</p>
<p>For example, to set the color for the next drawing operation to (bg: dark_blue, fg: red).</p>
<pre><code class="language-c">c8_color(0x18);
c8_print(0, 0, &quot;@&quot;);
</code></pre>
<h5>void c8_fill(u8 x, u8 y, u8 w, u8 h, u8 chr)</h5>
<p>Set the characters in the rectangle [<code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>] to <code>chr</code>.</p>
<h5>void c8_put(u8 x, u8 y, char c)</h5>
<p>Places a glyph at [<code>x</code>, <code>y</code>].</p>
<h5>void c8_get( x, y )</h5>
<p>Returns the character at [<code>x</code>, <code>y</code>].</p>
<h5>void c8_print(u8 x, u8 y, const char *str)</h5>
<p>Places text at [<code>x</code>, <code>y</code>].</p>


</main>

<footer>
</footer>

</body>
</html>